// Singular library normaliz.lib

version="$Id$"
category="Commutative algebra"
info="
LIBRARY: normaliz.lib  Provides an interface for the use of Normaliz 2.2
         within SINGULAR.
AUTHORS:  Winfried Bruns, Winfried.Bruns@Uni-Osnabrueck.de
          Christof Soeger, Christof.Soeger@Uni-Osnabrueck.de

OVERVIEW:
@texinfo
The library normaliz.lib provides an interface for the use of Normaliz 2.2
within SINGULAR. The exchange of data is via files, the only possibility
offered by Normaliz in its present version. In addition to the top level
functions that aim at objects of type ideal or ring, several other auxiliary
functions allow the user to apply Normaliz to data of type intmat. Therefore
SINGULAR can be used as a comfortable environment for the work with Normaliz.
@* Please see the @code{Normaliz2.2Documentation.pdf} and @code{nmz_sing.pdf}
(both are included in the Normaliz distribution) for a more extensive
documentation of Normaliz.
@*
@*Singular and Normaliz exchange data via files. These files are automatically
created and erased behind the scenes. As long as one wants to use only the
ring-theoretic functions there is no need for file management.
@*
@*Note that the numerical invariants computed by Normaliz can be
accessed in this \"automatic file mode\".
@*
@*However, if Singular is used as a frontend for Normaliz or the user
wants to inspect data not automatically returned to Singular, then
an explicit filename and a path can be specified for the exchange of
data. Moreover, the library provides functions for access to these files.
Deletion of the files is left to the user.
@*
@* Use of this library requires the program Normaliz to be installed.
You can download it from
@uref{http://www.mathematik.uni-osnabrueck.de/normaliz/}. Please make sure
that the executables are in the search path or use setNmzExecPath
(@ref{setNmzExecPath}).
@end texinfo
NOTE:    These library functions use @code{sed} to transfer the Normaliz
output into a SINGULAR compliant format.


KEYWORDS: integral closure; normalization

PROCEDURES:
 intclToricRing(ideal I)      computes the integral closure of the toric ring
                              generated by the leading monomials of the
                              elements of I in the basering
 normalToricRing(ideal I)     computes the normalization of the toric ring
                              generated by the leading monomials of the
                              elements of I
 ehrhartRing(ideal I)         computes the monomials representing the lattice
                              points of the polytop generated leading monomials
                              of the elements of I
 intclMonIdeal(ideal I)       the exponent vectors of the leading monomials of
                              the elements of I are considered as generators of
                              a monomial ideal whose Rees algebra is computed

 torusInvariants(intmat T)    computes the ring of invariants of a torus action
 valRing(intmat V)            computes the intersection of the polynomial ring
                              with the valuation rings of monomial valuations
 valRingIdeal(intmat V)       computes ideals of monomial valuations

 showNuminvs()                prints the numerical invariants
 exportNuminvs()              exports the numerical invariants

 setNmzOption(string s, int onoff) sets the option s to onoff
 showNmzOptions()             prints the enabled options to the standard output

 normaliz(intmat sgr,int nmz_mode) applies Normaliz
 setNmzVersion(string nmz_version_name) sets the version of the Normaliz
                                        executable
 setNmzExecPath(string nmz_exec_path_name) sets the path to the Normaliz
                                           executable

 writeNmzData(intmat sgr, int n_mode) creates an input file for Normaliz
 readNmzData(string nmz_suffix) reads the Normaliz output file with the
                                specified suffix

 setNmzFilename(string nmz_filename_name) sets the filename for the exchange
                                          of data
 setNmzDataPath(string nmz_data_path_name) sets the directory for the exchange
                                           of data
 writeNmzPaths()              writes the path names into two files
 startNmz()                   retrieves the path names written by writeNmzPaths
 rmNmzFiles()                 removes the files created for and by Normaliz

 mons2intmat(ideal I)         returns the intmat whose rows represent the
                              leading exponents of the elements of I
 intmat2mons(intmat expo_vecs) returns the ideal generated by the monomials
                               which have the rows of expo_vecs as
                               exponent vector
";


// helpers

static proc desInt(string intname, int value)
// define, export and set an integer
{
    int exists;
    if(defined(`intname`)){exists=1;}
    if(!exists)
    {
        int `intname`=value;export(`intname`);
    }
    `intname`=value;
}

static proc desString(string stringname, string value)
// define, export and set a string
{
    int exists;
    if(defined(`stringname`)){exists=1;}
    if(!exists)
    {
        string `stringname`=value;export(`stringname`);
    }
    `stringname`=value;
}

static proc queryInt(string intname)
// if intname is defined, return(intname), else return(0)
{
    int exists,value;
    if(defined(`intname`)){exists=1;}
    if(!exists)
    {
        return(0);
    }
    return(`intname`);
}

static proc queryString(string stringname)
// if stringname is defined, return(stringname), else return("")
{
    int exists;
    string value;
    if(defined(`stringname`)){exists=1;}
    if(!exists)
    {
        return("");
    }
    return(`stringname`);
}

static proc fileExists(string f)
{
    return(status (f,"exists")=="yes");
}

static proc appendSlash(string s)
// if nonempty and / is not the terminating char
{
    if(size(s)>0)
    {
        if(s[size(s)]!="/")
        {
            s=s+"/";
            return(s);
        }
    }
    return(s);
}

// filenames and paths

proc setNmzExecPath(string nmz_exec_path_name)
"USAGE:   setNmzExecPath(string s);   @code{s} path to the Normaliz executable
CREATE:   @code{Normaliz::nmz_exec_path} to save the given path @code{s}
NOTE:     It is not necessary to use this function if the Normaliz executable
          is in the search path of the system.
SEE ALSO: setNmzVersion
EXAMPLE:  example setNmzExecPath; shows an example"
{
    desString("nmz_exec_path",nmz_exec_path_name);
    nmz_exec_path=appendSlash(nmz_exec_path);
}
example
{ "EXAMPLE:";echo = 2;
  setNmzExecPath("../Normaliz/");
}

proc setNmzVersion(string nmz_version_name)
"USAGE:   setNmzVersion(string s);  @code{s} version of the Normaliz executable
CREATE:   @code{Normaliz::nmz_version} to save the given version @code{s}
NOTE:     The version coincides with the filename of the Normaliz executable.
          Possible arguments are:
          @* @code{norm32} for 32bit integer precision
          @* @code{norm64} for 64bit integer precision (default)
          @* @code{normbig} for arbitrary precision
SEE ALSO: setNmzExecPath
EXAMPLE:  example setNmzVersion; shows an example
"
{
    desString("nmz_version",nmz_version_name);
}
example
{ "EXAMPLE:";echo = 2;
  setNmzVersion("normbig");
}


proc setNmzFilename(string nmz_filename_name)
"USAGE:   setNmzFilename(string s);
CREATE:   @code{Normaliz::nmz_filename} to save the given filename @code{s}
NOTE:     The function sets the filename for the exchange of data. Unless a
          path is set by setNmzDataPath, files will be created in the current
          directory.
          @* If a non-empty filename is set, the files created for and by
             Normaliz are kept. This is mandatory for the data access functions
             (see @ref{writeNmzData} and @ref{readNmzData}).
          @* Resetting the filename by setNmzFilename(\"\") forces the library
             to return to deletion of temporary files, but the files created
             while the filename had been set will not be erased.
SEE ALSO: writeNmzData, readNmzData, setNmzDataPath, rmNmzFiles
EXAMPLE:  example setNmzFilename; shows an example"
{
    desString("nmz_filename",nmz_filename_name);
    if(nmz_filename_name!="")
    {
        desInt("nmz_files_keep_switch",1);
    }
    else
    {
        desInt("nmz_files_keep_switch",0);
    }
}
example
{ "EXAMPLE:";echo = 2;
  setNmzDataPath("examples/");
  setNmzFilename("example1");
  //now the files for the exchange with Normaliz are examples/example1.SUFFIX
}

proc setNmzDataPath(string nmz_data_path_name)
"USAGE:   setNmzDataPath(string s);
CREATE:   @code{Normaliz::nmz_data_path} to save the given path @code{s}
NOTE:     The function sets the path for the exchange of data. By default the
          files will be created in the current directory.
          @* It seems that Singular cannot use filenames starting with @code{~}
             or @code{$HOME} in its input/output functions.
          @* You must also avoid path names starting with @code{/} if you work
             under Cygwin, since Singular and Normaliz interpret them in
             different ways.
SEE ALSO: writeNmzData, readNmzData, rmNmzFiles, setNmzFilename
EXAMPLE:  example setNmzDataPath; shows an example"
{
    desString("nmz_data_path",nmz_data_path_name);
    nmz_data_path=appendSlash(nmz_data_path);
}example
{ "EXAMPLE:";echo = 2;
  setNmzDataPath("examples/");
  setNmzFilename("example1");
  //now the files for the exchange with Normalize are examples/example1.SUFFIX
}

proc writeNmzPaths();
"USAGE:   writeNmzPaths();
CREATE:   the file nmz_sing_exec.path where the path to the Normaliz executable
          is saved
          @* the file nmz_sing_data.path where the directory for the exchange
          of data is saved
NOTE:     Both files are saved in the current directory. If one of the names
          has not been defined, the corresponding file is created, but
          contains nothing.
SEE ALSO: setNmzDataPath, setNmzExecPath, startNmz
EXAMPLE:  example writeNmzPaths; shows an example
"{
    link outf=":w nmz_sing_exec.path";
    write(outf, queryString("nmz_exec_path"));
    close(outf);

    outf=":w nmz_sing_data.path";
    write(outf, queryString("nmz_data_path"));
    close(outf);
}
example
{ "EXAMPLE:";echo = 2;
  setNmzExecPath("../Normaliz/");
  writeNmzPaths();
  int dummy=system("sh","cat nmz_sing_exec.path");
  dummy=system("sh","cat nmz_sing_data.path");
}

proc startNmz()
"USAGE:   startNmz();
PURPOSE:  This function reads the files written by @code{writeNmzPaths()},
          retrieves the path names, and types them on the standard output
          (as far as they have been set). Thus, once the path names have been
          stored, a Normaliz session can simply be opened by this function.
SEE ALSO: setNmzDataPath, setNmzExecPath, writeNmzPaths
EXAMPLE:  example startNmz; shows an example
"
{
    link inf=":r nmz_sing_exec.path";
    string s=read(inf);
    int i,p;
    p=findWord("/",s,1);
    if(p!=-1)
    {
        for(i=size(s);i>=1;i--)
        {
            if(s[i]=="/")
            {
                s=s[1..i];
                break;
            }
        }
        desString("nmz_exec_path",s);
        "nmz_exec_path is",nmz_exec_path;
    }
    else
    {
        "nmz_exec_path not set";
    }

    inf=":r nmz_sing_data.path";
    s=read(inf);
    p=findWord("/",s,1);
    if(p!=-1)
    {
        for(i=size(s);i>=1;i--)
        {
            if(s[i]=="/")
            {
                s=s[1..i];
                break;
            }
        }
        desString("nmz_data_path",s);
        "nmz_data_path is",nmz_data_path;
    }
    else
    {
        "nmz_data_path not set";
    }
}
example
{ "EXAMPLE:"; echo=2;
  startNmz();
}

static proc getNmzFile()
{
    if(queryInt("nmz_files_keep_switch"))
    {
        return(queryString("nmz_data_path")+queryString("nmz_filename"));
    }
    else
    {
        return(queryString("nmz_filename"));
    }
}

static proc makeTempNmzDataPath()
{
    string testdir, testdir1;
    int i,dummy;

    testdir1="/tmp/nmz_sing_"+string(system("pid"));
    testdir=testdir1;
    while(fileExists(testdir))
    {
        i++;
        testdir=testdir1+string(i);
    }
    dummy=system("sh","mkdir "+ testdir);
    desString("nmz_filename",testdir+"/nmz"); //files are nmz+suffix in testdir
}

static proc eraseTempNmzDataPath();
{
    int dummy;

    string tmpdir=getNmzFile();
    tmpdir=tmpdir[1..size(tmpdir)-4]; // remove "/nmz"
    dummy=system("sh","rm -r "+tmpdir);
    setNmzFilename("");
}

static proc setNmzExec()
{
    if(queryString("nmz_exec")=="")
    {
        return(queryString("nmz_exec_path")+"norm64");
    }
    return(queryString("nmz_exec_path")+queryString("nmz_exec"));
}

proc rmNmzFiles()
"USAGE:  rmNmzFiles();
PURPOSE: This function removes the files created for and by Normaliz, using
         the last filename specified.
         It needs an explicit filename set (see @ref{setNmzFilename}).
SEE ALSO: writeNmzData, readNmzData, setNmzFilename, setNmzDataPath
EXAMPLE:  example rmNmzFiles; shows an example
"{

    if(!queryInt("nmz_files_keep_switch"))
    {
        ERROR("rmNmzFiles: no filename specified");
    }

    list suffixes="in","gen","out","sup","typ","egn","esp","inv","tri","ht1",
                  "ext";
    int i,dummy;
    string f;

    for(i=1;i<=size(suffixes);i++)
    {
        f=getNmzFile()+"."+suffixes[i];
        dummy=system("sh","rm "+f+ "&> /dev/null");
    }
}
example
{ "EXAMPLE:"; echo=2;
  setNmzFilename("VeryInteresting");
  rmNmzFiles();
}



// parsing normaliz output

static proc digit(string s)
{
    if(s==" ") // skip blanks quickly
    {
        return(0);
    }

    if((s[1]>="0" && s[1]<="9")||s[1]=="-")
    {
        return(1);
    }
    return(0);
}

static proc nextWord(string s, int p)
{
    int j,sw,ew;

    for(;p<=size(s);p++) // must start with a letter
    {

        if((s[p]>="a" && s[p]<="z")||
             (s[p]>="A" && s[p]<="Z"))
        {
            sw=p; break;
        }
    }
    if(p>size(s))
    {
        return(-1,-1); // no word found
    }

    for(;p<=size(s);p++) // now numerals and -_ allowed
    {
        if(!((s[p]>="a" && s[p]<="z")||
             (s[p]>="A" && s[p]<="Z")||
             (s[p]>="0" && s[p]<="9")||
              s[p]=="_"||s[p]=="-"))
        {
            break;
        }
    }
    return(sw,p);
}

static proc getInt(string s, int p)
{

    string nst;
    int i,j,en,sn;

    for(;p<=size(s);p++)
    {

        if(digit(s[p]))
        {
            sn=p; break;
        }
    }
    if(not(sn))
    {
        return(0,-1); // -1 indicates: no number found
    }
    p++;
    for(;p<=size(s);p++)
    {
        if(!digit(s[p]))
        {
            en=p-1; break;
        }
    }
    if(p>size(s))
    {
        en=size(s);
    }
    nst="i="+s[sn,en-sn+1];
    execute(nst);
    return(i,p);
}

static proc getRational(string s, int p)
{

    string nst;
    int i,j,en,sn;

    for(;p<=size(s);p++)
    {
        if(digit(s[p]))
        {
            sn=p; break;
        }
    }
    if(not(sn))
    {
        return(0,-1); // -1 indicates: no number found
    }
    p++;
    int slash_at;
    for(;p<=size(s);p++)
    {
        if(s[p]=="/")
        {
            slash_at=p;
            p++;
            continue;
        }
        if(!digit(s[p]))
        {
            en=p-1; break;
        }
    }
    if(p>size(s))
    {
        en=size(s);
    }
    if(slash_at)
    {
        nst="i="+s[sn,slash_at-sn];
        execute(nst);
        nst="j="+s[slash_at+1,en-slash_at];
        execute(nst);
        return(i,p,j);
    }
    nst="i="+s[sn,en-sn+1];
    execute(nst);
    return(i,p);
}

static proc findWord(string s, string t, int p)
{
    for(;p<=size(t)-size(s)+1;p++)
    {
        if(t[p]==s[1])
        {
            if(t[p,size(s)]==s)
            {
                 return(p+size(s));
            }
        }
    }
    return(-1);
}

static proc skipEqualsign(string s,int p)
{
    for(;p<=size(s);p++)
    {
        if(s[p]=="=")
        {
            break;
        }
    }
    return(p+1);
}


// input and output to/from normaliz

static proc doWriteNmzData(intmat sgr, int num_cols, n_mode)
{
    string s;
    int j;
    link outf=":w "+ getNmzFile() +".in";  // also sets the filename
    write(outf,nrows(sgr));
    write(outf,num_cols);

    for(int i=1;i<=nrows(sgr);i++)
    {
        s="";
        for(j=1;j<=num_cols;j++)
        {
             s=s+string(sgr[i,j])+" ";
        }
        write(outf,s);
    }
    write(outf,n_mode);
    close(outf);
}

proc writeNmzData(intmat sgr, int n_mode)
"USAGE:   writeNmzData(intmat M, int mode);
CREATE:   Creates an input file for Normaliz from the matrix M. The second
          parameter sets the mode. How the matrix is interpreted depends on the
          mode. See the Normaliz documentation for more information.
NOTE:     Needs an explicit filename set. The filename is created from the
          current filename and the suffix given to the function.
   @*     Note that all functions in normaliz.lib write and read their data
          automatically to and from the hard disk so that writeNmzData will
          hardly ever be used explicitly.
SEE ALSO: readNmzData, rmNmzFiles, setNmzFilename, setNmzDataPath
EXAMPLE:  example writeNmzData; shows an example"
{
    if(queryString("nmz_filename")=="")
    {
        ERROR("writeNmzData: no filename specified");
    }
    doWriteNmzData(sgr, ncols(sgr), n_mode);
}
example
{ "EXAMPLE:"; echo=2;
  setNmzFilename("VeryInteresting");
  intmat sgr[3][3]=1,2,3,4,5,6,7,8,10;
  writeNmzData(sgr,1);
  int dummy=system("sh","cat VeryInteresting.in");
}


proc readNmzData(string nmz_suffix)
"USAGE:  readNmzData(string suffix);
RETURN:  Reads an output file of Normaliz containing an integer matrix and
         returns it as an intmat. For example, this function is useful if one
         wants to inspect the support hyperplanes. The filename is created
         from the current  filename and the suffix given to the function.
NOTE:    Needs an explicit filename set by setNmzFilename.
   @*    Note that all functions in normaliz.lib write and read their data
         automatically so that readNmzData will usually not be used explicitly.
   @*    This function uses the command @code{sed} to transfer the normaliz
         output into a singular conform format.
SEE ALSO: writeNmzData, rmNmzFiles, setNmzFilename, setNmzDataPath
EXAMPLE:  example readNmzData; shows an example"
{
    if(queryString("nmz_filename")=="")
    {
        ERROR("readNmzData: no filename specified");
    }

    string s;
    int n_rows,n_cols;            //number of rows/columns
    int p, q;                     //positions
    int returnvalue;

    string filename = getNmzFile() + "."+ nmz_suffix;
    string tmpfilename = filename+".tmp";
//"// ** readNmzData: initialisiert";    //TODO debugoutput wieder rausnehmen
    returnvalue = system("sh","sed 's/ /,/g' < "+filename+" > "+tmpfilename);
//"// ** readNmzData: sed ausgefuehrt";
    link in_f=":r "+ tmpfilename;

    s=read(in_f);
    close(in_f);
    returnvalue = system("sh","rm "+tmpfilename);
//"// ** readNmzData: datei eingelesen";
    p=1; q=size(s);
    (n_rows,p)=getInt(s,p);
    (n_cols,p)=getInt(s,p);
    //intmat nmz_gen[n_rows][n_cols];
    while(s[q]!=",")
    {
      q--;
    }
    //string c = "nmz_gen=" + s[p,q-p] + ";";
    string c = "intmat nmz_gen["+ string(n_rows) +"]["+ string(n_cols) +"]="
             + s[p,q-p] + ";";
//"// ** readNmzData: string gebastelt";
    execute(c);
//"// ** readNmzData: string ausgefuehrt";
    return(nmz_gen);
}
example
{ "EXAMPLE:"; echo=2;
  setNmzFilename("VeryInteresting");
  intmat sgr[3][3]=1,2,3,4,5,6,7,8,10;
  intmat sgrnormal=normaliz(sgr,0);
  readNmzData("sup");
  readNmzData("typ");
}


// running normaliz (with options)

// component 1 is name of option
// 2 is default value
// 3 is command line option to be passed to Normaliz
// 4 indictes whether file "gen" is generated
// value 2 of 4 indicates "no influence"

static proc defNmzOptions()
{
    if(!defined(nmz_options)) // can be defined only once
    {
        list nmz_options=
        list("hvect",0,"-p",0),
        list("triang",0,"-v",0),
        list("supp",0,"-s",0),
        list("normal",0,"-n",1),
        list("hilb",0,"-h",1),
        list("dual",0,"-d",1),
        list("control",0,"-c",2),
        list("allf",0,"-a",2),
        list("ignore",1,"-i",2),
        list("errorcheck",0,"-e",2);
        export(nmz_options);
    }
}

proc setNmzOption(string s, int onoff)
"USAGE:   setNmzOption(string s, int onoff);
PURPOSE:  If @code{onoff=1} the option @code{s} is activated, and
          if @code{onoff=0} it is deactivated.
The Normaliz options are accessible via the following names:
@* @code{-s:  supp}
@* @code{-v:  triang}
@* @code{-p:  hvect}
@* @code{-n:  normal}
@* @code{-h:  hilb}
@* @code{-d:  dual}
@* @code{-a:  allf}
@* @code{-c:  control}
@* @code{-i:  ignore}
@* @code{-e:  errorcheck}
SEE ALSO: showNmzOptions
EXAMPLE:  example setNmzOption; shows an example
"
{
    defNmzOptions();
    for(int i=1;i<=size(nmz_options);i++)
    {
        if(s==nmz_options[i][1])
        {
            nmz_options[i][2]=onoff;
            return(1);
        }
    }
    "Invalid option ", s;
    return(0);
}
example
{ "EXAMPLE:"; echo=2;
  setNmzOption("hilb",1);
  showNmzOptions();
}

static proc collectNmzOptions()
{
    defNmzOptions();
    string run_options=" -f ";
    desInt("GenGen",1); // indicates whether "gen" is generated
    for(int i=1;i<=size(nmz_options);i++)
    {
        if(nmz_options[i][2])
        {
            run_options=run_options+nmz_options[i][3]+" ";
            if(nmz_options[i][4]!=2)
            {
                GenGen=nmz_options[i][4];
            }
        }
    }
    return(run_options+" ");
}

proc showNmzOptions()
"USAGE:   showNmzOptions();
RETURN:   Returns the string of activated options.
NOTE:     This string is used as parameter when calling Normaliz.
SEE ALSO: setNmzOption
EXAMPLE:  example showNmzOption; shows an example
"
{
    return(collectNmzOptions());
}
example
{ "EXAMPLE:"; echo=2;
  setNmzOption("hilb",1);
  showNmzOptions();
}


static proc runNormaliz(intmat sgr,int num_cols, nmz_mode)
{
    if(!queryInt("nmz_files_keep_switch"))
    {
        makeTempNmzDataPath();
    }

    doWriteNmzData(sgr,num_cols,nmz_mode);

    if(queryInt("nmz_files_keep_switch"))
    {
       int dummy=system("sh",setNmzExec()+ collectNmzOptions() + getNmzFile());
    }
    else
    {
        string gotodir="/tmp";
        string fname=getNmzFile();
        fname=fname[6..size(fname)];
        string exec="cd "+gotodir+" ; ";
        exec=exec+setNmzExec()+ collectNmzOptions()+" ";
        exec=exec+fname+" ;";
        int dummy=system("sh",exec);
    }

    if(!GenGen) // return input matrix if "gen" has not been generated
    {
        if(!queryInt("nmz_files_keep_switch"))
        {
            eraseTempNmzDataPath();
        }
        return(sgr);
    }
    intmat Gen=readNmzData("gen");

    if(!defined(Num_Invs))
    {
        list Num_Invs;
        export Num_Invs;
    }
    Num_Invs=getNuminvs();

    if(!queryInt("nmz_files_keep_switch"))
    {
        eraseTempNmzDataPath();
    }

    return(Gen);

}

proc normaliz(intmat sgr,int nmz_mode)
"USAGE:   normaliz(intmat sgr,int nmz_mode);
RETURN:   The function applies Normaliz to the parameter sgr in the mode set
          by nmz_mode. The function returns the intmat defined by the file
          with suffix gen.
NOTE:     You will find procedures for many applications of Normaliz in this
          library, so the explicit call of this procedure may not be necessary.
SEE ALSO: intclToricRing, normalToricRing, ehrhartRing, intclMonIdeal,
          torusInvariants, valRing, valRingIdeal
EXAMPLE:  example normaliz; shows an example
"
{
    return(runNormaliz(sgr,ncols(sgr),nmz_mode));
}
example
{ "EXAMPLE:"; echo=2;
  ring R=0,(x,y,z),dp;
  intmat M[3][2]=3,1,
                 3,2,
                 1,3;
  normaliz(M,1);
}


// retrieving normaliz numerical invariants

static proc getNuminvs()
{
    string s;
    list num_invs;
    int p,sw,v_length,i,dummy_int;
    intvec dummy_vec;
    string type_inv,name_inv,dummy_bool;

    link in_f=":r "+ getNmzFile() + "."+"inv";
    s=read(in_f);

    p=1;
    while(p<size(s))
    {
        (sw,p)=nextWord(s,p);
        if(sw==-1)
        {
            break;
        }
        type_inv=s[sw..p-1];
        if(type_inv=="vector")
        {
            (v_length,p)=getInt(s,p);
            (sw,p)=nextWord(s,p);
            name_inv=s[sw..p-1];
            if(name_inv=="h-vector")
            {
                name_inv="h_vector";
            }
            if(name_inv!="hilbert_polynomial")
            {
                for(i=1;i<=v_length;i++)
                {
                    if(i==1)
                    {
                        (dummy_int,p)=getInt(s,p);
                        dummy_vec=dummy_int;
                    }
                    else
                    {
                        (dummy_int,p)=getInt(s,p);
                        dummy_vec=dummy_vec,dummy_int;
                    }
                }
                num_invs=num_invs+list(list(name_inv,dummy_vec,"intvec"));
            }
            else
            {
                p=skipEqualsign(s,p);
            }
        }
        if(type_inv=="integer")
        {
            (sw,p)=nextWord(s,p);
            name_inv=s[sw..p-1];
            (dummy_int,p)=getInt(s,p);
            num_invs=num_invs+list(list(name_inv,dummy_int,"int"));
        }
        if(type_inv=="boolean")
        {
            (sw,p)=nextWord(s,p);
            name_inv=s[sw..p-1];
            p=skipEqualsign(s,p);
            (sw,p)=nextWord(s,p);
            dummy_bool=s[sw..p-1];
            dummy_int=0;
            if(dummy_bool=="true")
            {
                dummy_int=1;
            }
            num_invs=num_invs+list(list(name_inv,dummy_int,"int"));
        }
    }
    return(num_invs);
}

proc showNuminvs()
"USAGE:   showNuminvs();
PURPOSE:  prints the numerical invariants
SEE ALSO: exportNuminvs
EXAMPLE:  example showNuminvs(); shows an example
"
{
    list dummy;
    int i;
    for(i=1;i<=size(Num_Invs);i++)
    {
        dummy=Num_Invs[i];
        dummy[1],":", dummy[2];
    }
}
example
{ "EXAMPLE:"; echo=2;
  ring R=0,(x,y,z,t),dp;
  ideal I=x^2,y^2,z^3;
  list l=intclMonIdeal(I);
  showNuminvs();
}


proc exportNuminvs()
"USAGE:   exportNuminvs();
CREATE:   Creates top-level variables which contain the numerical invariants.
          Depending on the options of normaliz different invariants are
          calculated. Use showNuminvs (@ref{showNuminvs}) to see which
          invariants are available.
SEE ALSO: showNuminvs
EXAMPLE:  example exportNuminvs; shows an example
"
{
    list dummy;
    int i;
    string s;
    for(i=1;i<=size(Num_Invs);i++)
    {
        dummy=Num_Invs[i];
        s=dummy[3]+" nmz_" + dummy[1] + "=dummy[2]; exportto(Top," + "nmz_" + dummy[1] + ");";
        execute(s);
    }
}
example
{ "EXAMPLE:"; echo=2;
  ring R=0,(x,y,z,t),dp;
  ideal I=x^2,y^2,z^3;
  list l=intclMonIdeal(I);
  exportNuminvs();
  // now the following variables are set:
  nmz_hilbert_basis_elements;
  nmz_number_extreme_rays;
  nmz_rank;
  nmz_index;
  nmz_number_support_hyperplanes;
  nmz_homogeneous;
  nmz_primary;
  nmz_ideal_multiplicity;
}


// intmats to/from monomials

proc mons2intmat(ideal I)
"USAGE:   mons2intmat(ideal I);
RETURN:   Returns the intmat whose rows represent the leading exponents of the
          (non-zero) elements of I. The length of each row is nvars(basering).
SEE ALSO: intmat2mons
EXAMPLE:  example mons2intmat; shows an example"
{
    int i,j,k;
    intmat expo_vecs[size(I)][nvars(basering)];
    intvec expo_v;

    int last_comp;
    k=0;
    for(i=1;i<=ncols(I);i++)
    {
        if(I[i]!=0)
        {
            k++;
            expo_v=leadexp(I[i]);
            for(j=1;j<=nvars(basering);j++)
            {
                expo_vecs[k,j]=expo_v[j];
            }
        }
    }
    return(expo_vecs);
}
example
{ "EXAMPLE:"; echo=2;
  ring R=0,(x,y,z),dp;
  ideal I=x2,y2,x2yz3;
  mons2intmat(I);
}

proc intmat2mons(intmat expo_vecs)
"USAGE:   intmat2mons(intmat M);
RETURN:   an ideal generated by the monomials which correspond to the exponent
          vectors given by the rows of @code{M}
NOTE:     The number of variables in the basering @code{nvars(basering)} has to
          be at least the number of columns @code{ncols(M)}, otherwise the
          function exits with an error.
          is thrown (see @ref{ERROR}).
SEE ALSO: mons2intmat
EXAMPLE:  example intmat2mons; shows an example
"
{
    int i,j;
    poly m;
    ideal mons;

    if(nvars(basering)<ncols(expo_vecs))
    {
        ERROR("intmat2mons: not enough variables in ring");
    }

    for(i=1;i<=nrows(expo_vecs);i++)
    {
        m=1;
        for(j=1;j<=ncols(expo_vecs);j++)
        {
            m=m*var(j)^expo_vecs[i,j];
        }
        mons=mons,m;
    }
     mons=simplify(mons,2);    // get rid of starting 0
     return(mons);
}
example
{ "EXAMPLE:"; echo=2;
  ring R=0,(x,y,z),dp;
  intmat expo_vecs[3][3] =
  2,0,0,
  0,2,0,
  2,1,3;
  intmat2mons(expo_vecs);
}

static proc intmat2monsSel(intmat expo_vecs, int d)
{
    int i,j;
    poly m;
    ideal mons;

    if(nvars(basering)<ncols(expo_vecs)-1)
    {
        ERROR("intmat2monsSel: not enough variables in ring");
    }

    for(i=1;i<=nrows(expo_vecs);i++)
    {
        if(expo_vecs[i,ncols(expo_vecs)]==d)
        {

            m=1;
            for(j=1;j<=ncols(expo_vecs)-1;j++)
            {
                m=m*var(j)^expo_vecs[i,j];
            }
            mons=mons,m;
        }
    }
     mons=simplify(mons,2);    // get rid of starting 0
     return(mons);
}



// integral closure of rings and ideals

static proc runIntclToricRing(ideal I, int nmz_mode)
{
    intmat expo_vecs=mons2intmat(I);

    string dummy=collectNmzOptions(); // only to set GenGen

/*    if(!GenGen) // return I
    {
        runNormaliz(expo_vecs,ncols(expo_vecs),nmz_mode);
        return(I);
    }
*/    return( intmat2mons( runNormaliz(expo_vecs,ncols(expo_vecs),nmz_mode) ) );
}

proc intclToricRing(ideal I)
"USAGE:   intclToricRing(ideal I);
RETURN:   The toric ring S is the subalgebra of the basering generated by the
          leading monomials of the elements of I. The function computes the
          integral closure T of S in the basering and returns an ideal listing
          the algebra generators of T over the coefficient field.
@*        The function returns the input ideal I if one of the options
          @code{supp}, @code{triang}, or @code{hvect} has been activated.
          However, in this case some numerical invariants are computed, and
          some other data may be contained in files that you can read into
          Singular (see @ref{showNuminvs}, @ref{exportNuminvs}).
NOTE:     A mathematical remark: the toric ring depends on the list of
          monomials given, and not only on the ideal they generate!
SEE ALSO:  normalToricRing, ehrhartRing, intclMonIdeal
EXAMPLE:   example intclToricRing; shows an example
"
{
    return(runIntclToricRing(I,0));
}
example
{ "EXAMPLE:"; echo=2;
  ring R=37,(x,y,t),dp;
  ideal I=x3,x2y,y3;
  intclToricRing(I);
}

proc normalToricRing(ideal I)
"USAGE:   normalToricRing(ideal I);
RETURN:   The toric ring S is the subalgebra of the basering generated by the
          leading monomials of the elements of I. The function computes the
          normalisation T of S and returns an ideal listing the algebra
          generators of T over the coefficient field.
@*        The function returns the input ideal I if one of the options
          @code{supp}, @code{triang}, or @code{hvect} has been activated.
          However, in this case some numerical invariants are computed, and
          some other data may be contained in files that you can read into
          Singular (see @ref{showNuminvs}, @ref{exportNuminvs}).
NOTE:     A mathematical remark: the toric ring depends on the list of
          monomials given, and not only on the ideal they generate!
SEE ALSO: intclToricRing, ehrhartRing, intclMonIdeal
EXAMPLE:  example normalToricRing; shows an example
"
{
    return(runIntclToricRing(I,1));
}
example
{ "EXAMPLE:"; echo=2;
  ring R=37,(x,y,t),dp;
  ideal I=x3,x2y,y3;
  normalToricRing(I);
}

static proc runIntclMonIdeal(ideal I, int nmz_mode)
{
    intmat expo_vecs=mons2intmat(I);
    int i,last_comp;

    // we test if there is room for the Rees algebra

    for(i=1;i<=nrows(expo_vecs);i++)
    {
        if(expo_vecs[i,ncols(expo_vecs)]!=0)
        {
            last_comp=1;  break; // no
        }
    }

    string dummy=collectNmzOptions(); // only to set GenGen

/*    if(!GenGen) // return I
    {
        runNormaliz(expo_vecs,ncols(expo_vecs),nmz_mode);
        return(list(I));
    }
*/
    intmat nmz_data=runNormaliz(expo_vecs,ncols(expo_vecs)-1+last_comp,
                                                                  nmz_mode);

    if(last_comp)
    {
        ideal I1=intmat2monsSel(nmz_data,1);
        return(list(I1));
    }
    else
    {
        ideal I1=intmat2monsSel(nmz_data,1);
        ideal I2=intmat2mons(nmz_data);
        return(list(I1,I2));
    }
}

proc ehrhartRing(ideal I)
"USAGE:    ehrhartRing(ideal I);
RETURN:    The exponent vectors of the leading monomials of the elements of I
           are considered as vertices of a lattice polytope P.
           The Ehrhart ring of a (lattice) polytope P is the monoid algebra
           defined by the monoid of lattice points in the cone over the
           polytope P; see Bruns and Gubeladze, Polytopes, Rings, and K-theory,
           Springer 2009, pp. 228, 229.
           The function returns a list of ideals:
@*         (i) If the last ring variable is not used by the monomials, it is
               treated as the auxiliary variable of the Ehrhart ring. The
               function returns two ideals, the first containing the monomials
               representing the lattice points of the polytope, the second
               containing the algebra generators of the Ehrhart ring over the
                    coefficient field.
@*         (ii) If the last ring variable is used by the monomials, the list
                returned contains only one ideal, namely the monomials
                representing the lattice points of the polytope.
@*
@*        The function returns the a list containing the input ideal I if one
          of the options @code{supp}, @code{triang}, or @code{hvect} has been
			 activated.
          However, in this case some numerical invariants are computed, and
          some other data may be contained in files that you can read into
          Singular (see @ref{showNuminvs}, @ref{exportNuminvs}).
NOTE:      A mathematical remark: the Ehrhart ring depends on the list of
           monomials given, and not only on the ideal they generate!
SEE ALSO: intclToricRing, normalToricRing, intclMonIdeal
EXAMPLE:  example ehrhartRing; shows an example
"
{
    return(runIntclMonIdeal(I,2));
}
example
{ "EXAMPLE:"; echo=2;
  ring R=37,(x,y,t),dp;
  ideal J=x3,x2y,y3,xy2t7;
  ehrhartRing(J);
}

proc intclMonIdeal(ideal I)
"USAGE:   intclMonIdeal(ideal I);
RETURN:   The exponent vectors of the leading monomials of the elements of I
          are considered as generators of a monomial ideal for which the
          normalization of its Rees algebra is computed. For a Definiton of the
          Rees algebra (or Rees ring) see Bruns and Herzog, Cohen-Macaulay
          rings, Cambridge University Press 1998, p. 182.
          The function returns a list of ideals:
@* (i) If the last ring variable is not used by the monomials, it is treated
       as the auxiliary variable of the Rees algebra. The function returns two
       ideals, the first containing the monomials generating the integral
       closure of the monomial ideal, the second containing the algebra
         generators of the normalization of the Rees algebra.
@* (ii) If the last ring variable is used by the monomials, the list returned
        contains only one ideal, namely the monomials generating the integral
        closure of the ideal.
@*        The function returns the a list containing the input ideal I if one
          of the options @code{supp}, @code{triang}, or @code{hvect} has been
			 activated.
          However, in this case some numerical invariants are computed, and
          some other data may be contained in files that you can read into
          Singular (see @ref{showNuminvs}, @ref{exportNuminvs}).
NOTE:     A mathematical remark: the Rees algebra depends on the list of
          monomials given, and not only on the ideal they generate!
SEE ALSO: intclToricRing, normalToricRing, ehrhartRing
EXAMPLE:  example intclMonIdeal; shows an example
"
{
    return(runIntclMonIdeal(I,3));
}
example
{ "EXAMPLE"; echo=2;
    ring R=0,(x,y,z,t),dp;
    ideal I=x^2,y^2,z^3;
    list l=intclMonIdeal(I);
    l[1]; // integral closure of I
    l[2];  // monomials generating the integral closure of the Rees algebra
}

// torus invariants and valuation rings and ideals

proc torusInvariants(intmat T)
"USAGE:   torusInvariants(intmat A);
RETURN:   @texinfo
Returns an ideal representing the list of monomials generating the ring of
invariants as an algebra over the coefficient field.
@tex
$R^T$.
@end tex
@*        The function returns the ideal given by the input matrix T if one of 
          the options @code{supp}, @code{triang}, or @code{hvect} has been
			 activated.
          However, in this case some numerical invariants are computed, and
          some other data may be contained in files that you can read into
          Singular (see @ref{showNuminvs}, @ref{exportNuminvs}).
@end texinfo
BACKGROUND: @texinfo
@tex
 Let $T = (K^*)^r$ be the $r$-dimensional torus acting on the polynomial ring
 $R = K[X_1 ,\ldots,X_n]$ diagonally. Such an action can be described as
 follows: there are integers $a_{i,j}$, $i=1,\ldots,r$, $j=1,\ldots,n$, such
 that $(\lambda_1,\ldots,\lambda_r)\in T$ acts by the substitution
$$ X_j \mapsto \lambda_1^{a_{1,j}} \cdots \lambda_r^{a_{r,j}}X_j,
   \quad j=1,\ldots,n.$$
In order to compute the ring of invariants $R^T$ one must specify the matrix
$A=(a_{i,j})$.
@end tex
@end texinfo
NOTE:@texinfo
@tex
It is of course possible that $R^T=K$. At present, Normaliz cannot deal with
the zero cone and will issue the (wrong) error message that the cone is not
pointed. The function also gives an error message if the matrix $T$ has the
wrong number of columns.
@end tex
@end texinfo
SEE ALSO: valRing, valRingIdeal
EXAMPLE:  example torusInvariants; shows an example
"
{
    if(nvars(basering)!=ncols(T))
    {
        ERROR("torusInvariants: wrong number of columns in matrix");
    }

    string dummy=collectNmzOptions();  // only to set GenGen

/*    if(!GenGen) // return T
    {
        runNormaliz(T,ncols(T),5);
        return(T);
    }
*/    return( intmat2mons( runNormaliz(T,ncols(T),5) ) );
}
example
{ "EXAMPLE:"; echo=2;
  ring R=0,(x,y,z,w),dp;
  intmat V0[2][4]=0,1,2,3, -1,1,2,1;
  valRing(V0);
}

proc valRing(intmat V)
"USAGE:   valRing(intmat V);
RETURN:   The function returns a monomial ideal, to be considered as the list
          of monomials generating @math{S} as an algebra over the coefficient
          field.
BACKGROUND: @texinfo
@tex
A discrete monomial valuation $v$ on $R = K[X_1 ,\ldots,X_n]$ is determined by
the values $v(X_j)$ of the indeterminates. This function computes the
subalgebra $S = \{ f \in R : v_i ( f ) \geq 0,\ i = 1,\ldots,r\}$ for several
such valuations $v_i$, $i=1,\ldots,r$. It needs the matrix $V = (v_i(X_j))$ as
its input.
@end tex
@end texinfo
@*        The function returns the ideal given by the input matrix V if one of 
          the options @code{supp}, @code{triang}, or @code{hvect} has been 
			 activated.
          However, in this case some numerical invariants are computed, and
          some other data may be contained in files that you can read into
          Singular (see @ref{showNuminvs}, @ref{exportNuminvs}).
NOTE:@texinfo
@tex
It is of course possible that $S=K$. At present, Normaliz cannot deal with the
zero cone and will issue the (wrong) error message that the cone is not
pointed. The function also gives an error message if the matrix $V$ has the
wrong number of columns.
@end tex
@end texinfo
SEE ALSO: torusInvariants, valRingIdeal
EXAMPLE:  example valRing; shows an example
"
{

    if(nvars(basering)!=ncols(V))
    {
        ERROR("valRing: wrong number of columns in matrix");
    }

    intmat V1[nrows(V)+ncols(V)][ncols(V)];
    int i,j;

    for(i=1;i<=ncols(V);i++)
    {
        V1[i,i]=1;
    }
    for(i=1;i<=nrows(V);i++)
    {
        for(j=1;j<=ncols(V);j++)
        {
            V1[i+ncols(V),j]=V[i,j];
        }
    }


    string dummy=collectNmzOptions();  // only to set GenGen

/*    if(!GenGen) // return V
    {
        runNormaliz(V1,ncols(V),4);
        return(V);
    }
*/
    return(intmat2mons(runNormaliz(V1,ncols(V),4)));
}
example
{ "EXAMPLE:"; echo=2;
  ring R=0,(x,y,z,w),dp;
  intmat V0[2][4]=0,1,2,3, -1,1,2,1;
  valRing(V0);
}

proc valRingIdeal(intmat V)
"USAGE:   valRingIdeal(intmat V);
RETURN:   The function returns two ideals, both to be considered as lists of
          monomials which generate an algebra over the coefficient field. The
          first is the system of monomial generators of @math{S}, the second
          the system of generators of @math{M}.
@*        The function returns a list consisting of the ideal given by the 
          input matrix T if one of the options @code{supp}, @code{triang}, or
			 @code{hvect} has been activated.
          However, in this case some numerical invariants are computed, and
          some other data may be contained in files that you can read into
          Singular (see @ref{showNuminvs}, @ref{exportNuminvs}).
BACKGROUND: @texinfo
@tex
A discrete monomial valuation $v$ on $R = K[X_1 ,\ldots,X_n]$ is determined by
the values $v(X_j)$ of the indeterminates. This function computes the
subalgebra $S = \{ f \in R : v_i ( f ) \geq 0,\ i = 1,\ldots,r\}$ for several
such valuations $v_i$, $i=1,\ldots,r$. It needs the matrix $V = (v_i(X_j))$ as
its input.

This function simultaneously determines the $S$-submodule
$M = \{ f \in R : v_i(f) \geq w_i ,\ i = 1,\ldots,r\}$ for integers
$w_1,\ldots\,w_r$. (If $w_i \geq 0$ for all $i$, $M$ is an ideal of $S$.)
The numbers $w_i$ form the $(n+1)$th column of the input matrix.
@end tex
@end texinfo
NOTE:@texinfo
@tex
It is of course possible that $S=K$. At present, Normaliz cannot deal with the
zero cone and will issue the (wrong) error message that the cone is not
pointed. The function also gives an error message if the matrix $T$ has the
wrong number of columns.
@end tex
@end texinfo
SEE ALSO: torusInvariants, valRing
EXAMPLE:  example valRingIdeal; shows an example
"
{
    if(nvars(basering)!=ncols(V)-1)
    {
        ERROR("valRingIdeal: wrong number of columns in matrix");
    }

    intmat V1[nrows(V)+ncols(V)][ncols(V)];
    int i,j;

    for(i=1;i<=ncols(V);i++)
    {
        V1[i,i]=1;
    }
    for(i=1;i<=nrows(V);i++)
    {
        for(j=1;j<=ncols(V);j++)
        {
            V1[i+ncols(V),j]=V[i,j];
        }
    }
    for(i=1;i<=nrows(V);i++)
    {
        V1[i+ncols(V),ncols(V)]=-V1[i+ncols(V),ncols(V)];
    }

    string dummy=collectNmzOptions();  // only to set GenGen

/*    if(!GenGen) // return V
    {
        runNormaliz(V1,ncols(V),4);
        return(V);
    }
*/
    intmat nmz_data=runNormaliz(V1,ncols(V),4);

    ideal I1=intmat2monsSel(nmz_data,0);
    ideal I2=intmat2monsSel(nmz_data,1);
    return(list(I1,I2));
}
example
{ "EXAMPLE:"; echo=2;
 ring R=0,(x,y,z,w),dp;
 intmat V[2][5]=0,1,2,3,4, -1,1,2,1,3;
 valRingIdeal(V);
}
